"""
This file provides utilities for processing and analyzing calcium imaging microscopy movies.

"""

import os
from cupyx.scipy.ndimage import gaussian_filter

import numpy as np
import cupy as cp
from os.path import getsize
import napari
from skimage.io import imread
import tifffile
from math import floor, ceil
from skimage import measure
from cellpose import models
import pyclesperanto_prototype as pyp
from skimage.measure import  regionprops_table
from skimage.io import imsave
import shapely


#Size of the patches
MODELHEIGHT = 172
MODELWIDTH =   216
hwidth = int(MODELWIDTH/2)
hheight = int(MODELHEIGHT/2)

FILENAME =  'Image_001_001.raw'
mcFilename = '1-mc.tif'
previewFilename = 'ChanC_Preview.tif'
previewFilename2 = 'ChanA_Preview.tif' #New microscope. It is channel A
savefolder = 'processedMovies'

MAXCHUNKSIZE = 1024*288*2*6000 # MAX MEMORY ALLOWED IN GRAPHICS CARD. WARNING! IT IS PC DEPENDENT. Main server (16GB GPU) is 786432000


def getNImages(r,n,height, width, start = 0,):

    frameSize = width*height*2
    offset = start*frameSize
    r.seek(offset)
    st = r.read(n*frameSize)
    nparray = np.frombuffer(st,dtype = np.uint16).reshape((n, height, width))
    
    return nparray


def getPreviewImage(folder,filename = FILENAME):
    folder = folder
    fullpath = os.path.join(folder,filename)

    try:
        prev = imread(os.path.join(folder,previewFilename))
    except FileNotFoundError:
        prev = imread(os.path.join(folder,previewFilename2))

    width = prev.shape[1] 
    height = prev.shape[0]

    r = open(fullpath,'rb')

    a = getNImages(r,100,height,width)
    r.close()
    return a.mean(0)

def getImgInfo(folder,filename = FILENAME):
    fullpath = os.path.join(folder,filename)

    try:
        prev = imread(os.path.join(folder,previewFilename))
    except FileNotFoundError:
        prev = imread(os.path.join(folder,previewFilename2))

    width = prev.shape[1] 
    height = prev.shape[0]

    nbytes = getsize(fullpath)
    frameSize = width*height*2
    nFrames = int(nbytes/frameSize)  
    return (width,height,nFrames)

def calculateFrameIntervalsToRemove(jumpFrames=[],winLeft=None,winRight = None,jumpFramesMax=[],winMaxLeft = None,winMaxRight = None):
    """
    Calculates frame intervals to remove based on provided jump frames and window sizes.
    This function generates a list of intervals (start and end frames) to be removed
    around specified jump frames. It handles both minimum and maximum jump frames with
    their respective window sizes.
    Parameters
    ----------
    jumpFrames : list, optional
        List of frame indices where minimum jumps occur
    winLeft : int or None, optional
        Number of frames to remove before each minimum jump frame
    winRight : int or None, optional
        Number of frames to remove after each minimum jump frame
    jumpFramesMax : list, optional
        List of frame indices where maximum jumps occur
    winMaxLeft : int or None, optional
        Number of frames to remove before each maximum jump frame
    winMaxRight : int or None, optional
        Number of frames to remove after each maximum jump frame
    Returns
    -------
    list
        List of [start, end] frame intervals to remove. Each interval is inclusive
        of the boundary frames.

    """
    intervalsToRemove = []
    for thismin in jumpFrames:
        
        #framesToRemove.extend(list(np.arange(thismin-winLeft,thismin+winRight)))

        intervalsToRemove.append([thismin-winLeft,thismin+winRight])
    
    for thismax in jumpFramesMax:
        

        intervalsToRemove.append([thismax-winMaxLeft,thismax+winMaxRight])       

    return intervalsToRemove

class thorlabsFile():
    """
    A class to handle Thorlabs Bergamo II microscope (Thorimage software) binary files and perform basic operations.
    This class provides functionality to load and manipulate binary files generated by 
    the Bergamo 2p microscope. It supports loading whole stacks, frame intervals, and TIFF files,
    with optional GPU-accelerated Gaussian filtering and motion correction. Files are processed in GPU in memory chunks defined 
    by the MAXCHUNKSIZE global variable (change to avoid memory errors). The class also provides a napari viewer to display loaded frames.
    Required CUDA and CuPy libraries for GPU acceleration.
    Parameters
    ----------
    folder : str, optional
        Directory path containing the binary file.
    filename : str, optional
        Name of the binary file to load.
    applyGaussian : bool, default=True
        Whether to apply Gaussian filtering to loaded frames.
    showViewer : bool, default=True
        Whether to display frames using napari viewer.

    Methods
    -------
    loadFile(folder, filename, applyGaussian)
        Load a new binary file.
    loadWholeStack(start, end, pbar)
        Load a complete stack of frames from the file.
    loadNextNFrames(n)
        Load the next n frames from current position.
    loadUpToFrameN(n)
        Load frames up to specified frame number.
    loadFrameInterval(start, end, frameIntervalsToRemove, pbar)
        Load frames between start and end indices.
    loadFromTiff(fullpath)
        Load frames from a TIFF file.
    loadQuickLook(fullpath)
        Quick load of frames using dask for large files.
    applyMotionCorrection()
        Apply motion correction to loaded frames.
    """
   
    def __init__(self,folder=None,filename = FILENAME,applyGaussian = True,showViewer = True) -> None:
        if folder is not None:
            self.folder = folder
            self.fullpath = os.path.join(self.folder,filename)
            self.width,self.height, self.nFrames = getImgInfo(folder, filename)

            self.r = open(self.fullpath,'rb')
            self.frameSize = self.width*self.height*2
            
            self.currentLastFrame = 0
            self.applyGaussian = applyGaussian
            self.array = np.empty((0,self.height,self.width),dtype=np.uint16)
        if showViewer:
            self.app = napari.Viewer()
        else:
            self.app = None
        #    self.app.add_image(self.array)

    def loadFile(self,folder,filename = FILENAME, applyGaussian=True):

        try:
            self.r.close()
        except:
            pass
        
        self.folder = folder
        self.fullpath = os.path.join(self.folder,filename)
        self.width,self.height, self.nFrames = getImgInfo(folder,filename)

        self.r = open(self.fullpath,'rb')
        self.frameSize = self.width*self.height*2

        self.currentLastFrame = 0
        self.applyGaussian = applyGaussian
        self.array = np.empty((0,self.height,self.width),dtype=np.uint16)

    

    def loadWholeStack(self,start=0,end=-1,pbar=None):

        
        if end == -1:
            end = self.nFrames
        totalFrames = end-start
        totalFramesSize = totalFrames*self.frameSize

        if totalFramesSize<=MAXCHUNKSIZE:
            
            offset = start*self.frameSize
            self.r.seek(offset)
            st = self.r.read(totalFramesSize)
            stack = cp.frombuffer(st,dtype = np.uint16).reshape((totalFrames,self.height,self.width))


            if self.applyGaussian:
                stack = gaussian_filter(stack,(0,2,2))
                stack = gaussian_filter(stack,(2,0,0))
            stack3 = [cp.asnumpy(stack)]
            
        else:
            chunksizeFrames = MAXCHUNKSIZE//(self.frameSize)  #number of frames in a chunk
            nchunks = totalFrames//chunksizeFrames
            remainderFrames = totalFrames%chunksizeFrames
            stack3 = []
            for i in range(nchunks):
                offset = (start+i*chunksizeFrames)*self.frameSize
                self.r.seek(offset)
                st = self.r.read(self.frameSize*chunksizeFrames)
                stack = cp.frombuffer(st,dtype = np.uint16).reshape((chunksizeFrames,self.height,self.width))
                if self.applyGaussian:
                    stack = gaussian_filter(stack,(0,2,2))
                    stack = gaussian_filter(stack,(2,0,0))

                stack3.append(cp.asnumpy(stack))
                
                if pbar is not None:
                    pbar.value +=chunksizeFrames 

            if remainderFrames != 0:
                offset = (start+nchunks*chunksizeFrames)*self.frameSize
                self.r.seek(offset)
                st = self.r.read(self.frameSize*remainderFrames)
                stack = cp.frombuffer(st,dtype = np.uint16).reshape((remainderFrames,self.height,self.width))
                if self.applyGaussian:
                    stack = gaussian_filter(stack,(0,2,2))
                    stack = gaussian_filter(stack,(2,0,0))

                stack3.append(cp.asnumpy(stack))

                if pbar is not None:
                    pbar.value = self.nFrames
                
        cp._default_memory_pool.free_all_blocks()    
        return stack3

    def loadNextNFrames(self,n):
        newStacks = self.loadWholeStack(start=self.currentLastFrame,end = self.currentLastFrame+n)
        self.array= np.vstack([self.array, *newStacks])
        del newStacks
        if self.app is not None:
            try:
                l = self.app.layers['Image']
                l.data = self.array
            except:
                self.app.add_image(self.array)

        self.currentLastFrame = self.array.shape[0]

    def loadUpToFrameN(self,n):
        
        if (n!=-1) & ((n<self.currentLastFrame) | (n>self.nFrames)):
            return
        newStack = self.loadWholeStack(start=self.currentLastFrame,end = n)
        self.array= np.vstack([self.array, *newStack])

        del newStack
        if self.app is not None:
            try:
                l = self.app.layers['Image']
                l.data = self.array
            except:
                self.app.add_image(self.array)

        self.currentLastFrame = self.array.shape[0]

    def loadFrameInterval(self,start,end,frameIntervalsToRemove = None,pbar=None):
        self.currentLastFrame=start
        newStack = self.loadWholeStack(start=self.currentLastFrame,end = end,pbar=pbar)
        self.array= np.vstack([self.array, *newStack])
        
        if frameIntervalsToRemove is not None:  
            for el in frameIntervalsToRemove:
                try:
                    self.array[el[0]:el[1],:,:] = self.array[el[0]-1,:,:] 
                except IndexError:
                    print('Index to remove not in first-last anymore')

        del newStack
        if self.app is not None:
            try:
                l = self.app.layers['Image']
                l.data = self.array
            except:
                self.app.add_image(self.array)

        self.currentLastFrame = self.array.shape[0]

    def loadFromTiff(self,fullpath):
        """
        Load image data from a TIFF file and update the associated parameters.
        Parameters
        ----------
        fullpath : str
            Complete path to the TIFF file to be loaded.
        Returns
        -------
        None
        Notes
        -----
        This method updates several instance attributes:
            - array : numpy.ndarray
                The loaded image data
            - currentLastFrame : int
                Number of frames in the loaded data
            - folder : str
                Directory path containing the TIFF file
            - fullpath : str
                Complete path to the loaded file
            - nFrames : int
                Number of frames in the data
            - width : int
                Width of each frame
            - height : int
                Height of each frame
            - frameSize : int
                Size of each frame in bytes (width * height * 2)
        If the instance has an associated application (self.app), it will attempt to
        update or add the image to the application's layers.
        """
        self.array = tifffile.imread(fullpath)

        if self.app is not None:
            try:
                l = self.app.layers['Image']
                l.data = self.array
            except:
                self.app.add_image(self.array)
        self.currentLastFrame = self.array.shape[0]
        self.folder = os.path.split(fullpath)[0]
        self.fullpath = os.path.join(fullpath)
        self.nFrames, self.width,self.height, = self.array.shape
        self.frameSize = self.width*self.height*2
        
    def loadQuickLook(self,fullpath):
        """
        Load image data from a file path or list of file paths and display it in a Napari viewer.
        This method loads image data using dask_image.imread and updates the viewer if available.
        It handles both single file paths (string) and multiple file paths (list).
        Parameters
        ----------
        fullpath : str or list
            Either a single file path as a string or a list of file paths to load images from.
        Attributes Modified
        -----------------
        array : dask.array
            The loaded image data as a dask array
        currentLastFrame : int
            The number of frames in the loaded data
        folder : str
            Directory path containing the loaded file(s)
        fullpath : str
            Complete path to the loaded file
        nFrames : int
            Number of frames in the loaded data
        width : int
            Width of the images in pixels
        height : int
            Height of the images in pixels
        Notes
        -----
        Requires collections.abc for compatibility with newer Python versions.
        If self.app (Napari viewer) exists, it will update or create an 'Image' layer with the loaded data.
        """
        import collections.abc
        collections.Iterable = collections.abc.Iterable
        collections.Sized = collections.abc.Sized
        collections.Sequence = collections.abc.Sequence
        collections.Mapping = collections.abc.Mapping
        from dask_image import imread
        import dask as da


        if fullpath.__class__ == str:
            self.array = imread.imread(fullpath)
        elif fullpath.__class__ == list:
            imgs = []
            for pat in fullpath:
                imgs.append(imread.imread(pat))
            self.array = da.array.concatenate(imgs)


        
        if self.app is not None:
            try:
                l = self.app.layers['Image']
                l.data = self.array
            except:
                self.app.add_image(self.array)
        self.currentLastFrame = self.array.shape[0]
        self.folder = os.path.split(fullpath)[0]
        self.fullpath = os.path.join(fullpath)
        self.nFrames, self.width,self.height, = self.array.shape


    def applyMotionCorrection(self):
        #TODO: not implemented yet
        return



import ipywidgets as widgets
from ipywidgets import interact, Dropdown
import plotly.graph_objs as go
import pandas as pd 
import pyclesperanto_prototype as cle

def isLeft(line, c):
    a = shapely.Point(line.coords[0])
    b = shapely.Point(line.coords[-1])
    return (b.x - a.x)*(c.y - a.y) - (b.y - a.y)*(c.x - a.x) > 0;


def jupyterPy(tb):
    """
    Creates an interactive widget interface for analyzing calcium imaging data in Napari.
    This function creates a UI which can be embedded in jupyter notebooks with multiple tabs for different analysis tasks:
    1. IHCs (Inner Hair Cells) tab: For ROI creation, manipulation and trace extraction
    2. Calcium waves tab: For detecting and analyzing calcium wave propagation
    3. Bouton & fibres tab: For analyzing synaptic boutons and nerve fibres
    Parameters
    ----------
    tb : ThorlabsFile object
        A custom object containing the image data and metadata. Must have the following attributes:
        - array: numpy array containing the image data
        - app: napari viewer instance
        - folder: str, path to the data folder
        - nFrames: int, number of frames
        - width: int, image width
        - height: int, image height
        - frameSize: int, size of each frame in bytes
    Returns
    -------
    go.FigureWidget
        A plotly figure widget for displaying traces and analysis results
    Key Features
    -----------
    IHCs tab:
    - ROI creation using Cellpose
    - ROI manipulation (erosion, squarification)
    - Trace extraction and export
    Calcium waves tab:
    - Background subtraction
    - Wave detection using Voronoi-Otsu labeling
    - Wave navigation and visualization
    Bouton & fibres tab:
    - Tophat filtering
    - Automatic segmentation of hair cells and boutons
    - Automatic annotation of modiolar/pillar boutons
    - Assignment of boutons to hair cells
    Notes
    -----
    Requires the following dependencies:
    - napari
    - ipywidgets
    - plotly
    - cellpose
    - scikit-image
    - pyclesperanto
    - shapely
    - pandas
    - numpy
    """
    
    plotButton =  widgets.Button(description='Plot ROIs',button_style = 'primary')
    justAvgButton =   widgets.Button(description='Avg image',button_style = 'primary')
    avgButton =   widgets.Button(description='Create HCs labels',button_style = 'primary')
    erodeButton =   widgets.Button(description='Erode labels',button_style = 'primary')
    exportROIsbutton =  widgets.Button(description='Export traces',button_style = 'success')

    saveROIsbutton =  widgets.Button(description='Save labels',button_style = 'success')
    loadROIsbutton =  widgets.Button(description='Load labels',button_style = 'primary')
    cellprobSlider = widgets.FloatSlider(description='Cell prob',min=-8,max=8, value = 0,step = 0.1)

    
    radiusWidget = widgets.IntText(value=100,description='Cell radius:',disabled=False)
    areaLimitWidget = widgets.IntText(value=500,description='ROI are cutoff:',disabled=False)
    fig = go.FigureWidget(data=[],layout=go.Layout({ 'autosize':True }))

    squareROISSideWidget = widgets.IntText(value=5,description='Sqaure ROI semiSide:',disabled=False)
    squarifyButton = widgets.Button(description='Make ROIs square',button_style = 'warning')

    #Calcium waves buttons
    subtractBackgroundButton =   widgets.Button(description='Subtract background',button_style = 'primary')
    subtract10BackgroundButton =   widgets.Button(description='Subtract X background',button_style = 'primary')
    loadhclineButton = widgets.Button(description='Load HC line',button_style = 'primary')
    savehclineButton = widgets.Button(description='Save HC line',button_style = 'primary')

    backgroundFrameWidget = widgets.IntText(value=0,description='Frame:',disabled=False)
    subtract10FrameWidget = widgets.IntText(value=10,description='Frame:',disabled=False)
    scaleTimeButton =  widgets.Button(description='Downsample time X 2',button_style = 'primary')
    scaleSpaceButton =  widgets.Button(description='Bin 2 images',button_style = 'primary')
    spotSWidget = widgets.IntText(value=6,description='Spot sigma:',disabled=False)
    outlineSWidget = widgets.IntText(value=6,description='Outline sigma:',disabled=False)
    voronoiButton =  widgets.Button(description='Voronoi-otsu wave detection',button_style = 'primary')
    resetLabelsButton =  widgets.Button(description='Rearrange labels',button_style = 'primary')
    enlargeabelsButton =  widgets.Button(description='Scale labels X 2',button_style = 'primary')

    saveWavesButton = widgets.Button(description='Save wave detection',button_style = 'primary')
    loadWavesButton = widgets.Button(description='Load wave detection',button_style = 'primary')

    currentWaveWidget =  widgets.IntText(value=0,description='3D wave:',disabled=False)
    nextWaveButton =  widgets.Button(description='Next wave',button_style = 'primary')
    prevWaveButton =  widgets.Button(description='Prev wave',button_style = 'primary')
    
    currentPointWidget =  widgets.IntText(value=0,description='Points:',disabled=False)
    nextPointButton =  widgets.Button(description='Next point',button_style = 'primary')
    prevPointButton =  widgets.Button(description='Prev point',button_style = 'primary')

    loadKymoButton =  widgets.Button(description='Load kymo',button_style = 'primary')
    saveKymoShapesButton =  widgets.Button(description='Save kymo shapes',button_style = 'primary')
    loadKymoShapesButton =  widgets.Button(description='Load kymo shapes',button_style = 'primary')

    boxStack  = widgets.VBox([justAvgButton])
    boxStack2  = widgets.VBox([avgButton,erodeButton,radiusWidget,cellprobSlider])
    boxStack3 = widgets.VBox([saveROIsbutton,loadROIsbutton])
    boxStack8 = widgets.VBox([squarifyButton,squareROISSideWidget])

    boxStack4 = widgets.VBox([subtractBackgroundButton,backgroundFrameWidget, subtract10BackgroundButton,subtract10FrameWidget , scaleSpaceButton, loadhclineButton,savehclineButton])
    boxStack5 = widgets.VBox([spotSWidget,outlineSWidget, voronoiButton, resetLabelsButton,enlargeabelsButton, saveWavesButton, loadWavesButton])
    boxStack6 = widgets.VBox([currentWaveWidget,prevWaveButton,nextWaveButton,currentPointWidget,nextPointButton,prevPointButton])
    boxStack7 = widgets.VBox([loadKymoButton,saveKymoShapesButton,loadKymoShapesButton])

    #Fibres
    plotFibresButton =  widgets.Button(description='Plot ROIs',button_style = 'primary')
    exportROIsFibresButton =  widgets.Button(description='Export traces',button_style = 'primary')
    exportAnnotationsFibresButton = widgets.Button(description='Export Annotations',button_style = 'primary')
    areaLimitFibresWidget = widgets.IntText(value=150,description='ROI area cutoff:',disabled=False)

    topHatButton = widgets.Button(description='2 - Apply tophat',button_style = 'primary') 
    topHatRadius = widgets.IntText(value=10,description='Tophat radius:',disabled=False)
    voronoiFibresButton =  widgets.Button(description='2-Voronoi-otsu segmentation',button_style = 'primary')
    spotSFibresWidget = widgets.IntText(value=7,description='Spot & out sigma:',disabled=False)
    segmentHCFibresButton =   widgets.Button(description='3-Create HCs labels',button_style = 'primary') 
    radiusFbiresWidget = widgets.IntText(value=70,description='Cell radius:',disabled=False)
    annotateFibresButton = widgets.Button(description='4-Annotate fibres',button_style = 'primary') 
    assignFibresButton = widgets.Button(description='5-Pair boutons-hcs',button_style = 'primary') 
    
    cutoffWidget = widgets.IntText(value=75,description='Cutoff boutons/fibres',disabled=False)
    loadAnnotationsButton =  widgets.Button(description='Load Results',button_style = 'primary') 
    #topBox = widgets.HBox([boxStack,boxStack2,boxStack3,calculateShapesButton,boxStack4,boxStack5])
    topBox1 = widgets.HBox([widgets.VBox([plotButton,exportROIsbutton,areaLimitWidget]),boxStack2,boxStack8,boxStack3])
    topBox2 = widgets.HBox([boxStack4,boxStack5,boxStack6, boxStack7])
    topBox3 = widgets.HBox([widgets.VBox([topHatRadius,spotSFibresWidget,voronoiFibresButton,areaLimitFibresWidget]),\
                            widgets.VBox([segmentHCFibresButton,radiusFbiresWidget,annotateFibresButton,cutoffWidget,assignFibresButton]),\
                              widgets.VBox([plotFibresButton,exportROIsFibresButton,exportAnnotationsFibresButton]),           
                            loadAnnotationsButton        ])
    
    tab = widgets.Tab(children = [topBox1,topBox2,topBox3])
    tab.set_title(0,'IHCs')
    tab.set_title(1,'Calcium waves')
    tab.set_title(2,'Bouton & fibres')

    topBox = widgets.HBox([boxStack,tab])
    
    ui = widgets.VBox([topBox,fig])


    def on_plot_clicked(change):
        """
        Updates plots based on mask or wave ROI data in the viewer.
        This function handles two different cases:
        1. When 'Masks' layer is present: 
            - Processes 2D ROI masks
            - Filters small ROIs based on area threshold
            - Orders ROIs from left to right
            - Updates mask labels and features
            - Plots mean intensity traces for each ROI
        2. When 'Wave3DRois' layer is present:
            - Processes 3D ROI data
            - Extracts intensity profiles from image data
            - Plots mean intensity traces for each 3D ROI
        Parameters
        ----------
        change : object
             Event object containing information about the button click event
        Notes
        -----
        Requires:
        - A napari viewer instance with either 'Masks' or 'Wave3DRois' layer
        - For 'Masks': An area limit widget for ROI filtering
        - For both: An image layer containing intensity data
        - Access to plotly graph objects for visualization
        The function updates the plot in-place using the fig object.
        """

        if 'Masks' in [layer.name for layer in tb.app.layers]:
            mask = tb.app.layers['Masks'].data
            l = tb.app.layers['Masks']
            
            # reset label number
            mask = measure.label(mask)

            #sort masks from left to right
            props = measure.regionprops(mask)
            
            masks2 = mask.copy()
            #remove small rois
            for c in props:
                if c.area<areaLimitWidget.value:
                    masks2[mask==c.label] = 0




            # reset label number
            masks2 = measure.label(masks2)
            masks3 = masks2.copy()

            props = measure.regionprops(masks2)
            orderedLabels = np.argsort([c.centroid[1] for c in props])+1
            
            for i,el in enumerate(orderedLabels):

                masks3[masks2==el] = i+1

            masks2 = masks3
            l.data = masks2
            mask = l.data
            l.features =  regionprops_table(l.data+1,properties=('area','centroid',   # the +1 is so that it correctly allign in napari
                                        'orientation',
                                        'axis_major_length',
                                        'axis_minor_length'))
            fig.data = []

            for i in range(1,mask.max()+1):
                if np.size(np.argwhere(mask==i))>0:
                    z = tb.array[:,np.argwhere(mask==i)[:,0],np.argwhere(mask==i)[:,1]].mean(1)
                    #find removed frames
                    dz = np.diff(z)
                    keep = np.argwhere(dz!=0)
                    #print(keep.shape)
                    color = l.get_color(i)*255
                    color = "rgb({} , {} ,{}, {})".format( *color)
                    fig.add_scatter(y=z[keep[:,0]],x = np.arange(z.size)[keep[:,0]],line=go.scatter.Line(color=color),name='Roi '+ str(i))
        elif 'Wave3DRois' in [layer.name for layer in tb.app.layers]:

            #data2= tb.app.layers['Image'].data
            props = measure.regionprops(tb.app.layers['Wave3DRois'].data)
            waves=[]
            fig.data = []
            for i,c in enumerate(props):
                x1,x2 = c.bbox[1],c.bbox[4]
                y1,y2 = c.bbox[2],c.bbox[5]
                z1,z2 = c.bbox[0],c.bbox[3]
                d = tb.app.layers['Image'].data[z1-10:z2,x1:x2,y1:y2].mean(1).mean(1)
                color = tb.app.layers['Wave3DRois'].get_color(c.label)*255
                color = "rgb({} , {} ,{}, {})".format( *color)
                fig.add_scatter(y=d,x = np.arange(d.size),line=go.scatter.Line(color=color),name='Roi '+ str(c.label))
                
    plotButton.on_click(on_plot_clicked)
      

    def on_exportROIs_clicked(c):
        
        mask = tb.app.layers['Masks'].data

        zs = []
        df = pd.DataFrame()
        for i in range(1,mask.max()+1):
            if np.size(np.argwhere(mask==i))>0:
                z = tb.array[:,np.argwhere(mask==i)[:,0],np.argwhere(mask==i)[:,1]].mean(1)
                #find removed frames
                dz = np.diff(z)
                keep = np.argwhere(dz!=0)

                xs = np.arange(z.size)
                df['ROI_'+str(i)] = z

        df ['Frame'] = xs
        df.to_csv(os.path.join(tb.folder,'traces.csv'))

        on_saveRois_clicked(None)

    exportROIsbutton.on_click(on_exportROIs_clicked)

    def on_justAvgButton_clicked(c):
        arr = tb.app.layers['Image'].data.mean(0)

        try:
            l = tb.app.layers['Avg']
            l.data = arr
        except:
            tb.app.add_image(arr,name='Avg')
    justAvgButton.on_click(on_justAvgButton_clicked)

    def on_avgButton_clciked(change):

        arr = tb.app.layers['Image'].data.mean(0)

        try:
            l = tb.app.layers['Avg']
            l.data = arr
        except:
            tb.app.add_image(arr,name='Avg')
        model = models.Cellpose(gpu=False, model_type='cyto')

        masks, flows, styles, diams = model.eval(arr, diameter=radiusWidget.value, channels=[0,0], net_avg=True,cellprob_threshold = cellprobSlider.value,
                                                 flow_threshold=0)

        #sort masks from left to right
        props = measure.regionprops(masks)
        
        masks2 = masks.copy()
        #remove small rois
        for c in props:
            if c.area<areaLimitWidget.value:
                masks2[masks==c.label] = 0

        props = measure.regionprops(masks2)
        orderedLabels = np.argsort([c.centroid[1] for c in props])+1
        masks3 = masks2.copy()
        for i,el in enumerate(orderedLabels):

           masks3[masks2==el] = i+1

        masks = masks3
        


        try:
            l = tb.app.layers['Masks']
            l.data = masks
                            
            l.features =  regionprops_table(l.data+1,properties=('area','centroid',   # the +1 is so that it correctly allign in napari
                                                'orientation',
                                                'axis_major_length',
                                                'axis_minor_length'))
        except:
            tb.app.add_labels(masks,name='Masks', opacity = 0.3)
            l = tb.app.layers['Masks']
            l.features =  regionprops_table(l.data+1,properties=('area','centroid',   # the +1 is so that it correctly allign in napari
                                    'orientation',
                                    'axis_major_length',
                                    'axis_minor_length'))
            


    avgButton.on_click(on_avgButton_clciked)

    def on_erode_clicked(change):
        """
        Erode Masks ROIs by 1 pixel
        """
        masks = pyp.pull(pyp.erode_labels(tb.app.layers['Masks'].data))
        tb.app.layers['Masks'].data = masks
        tb.app.layers['Masks'].features =  regionprops_table(masks+1,properties=('area','centroid',   # the +1 is so that it correctly allign in napari
                                    'orientation',
                                    'axis_major_length',
                                    'axis_minor_length'))
        


    erodeButton.on_click(on_erode_clicked)


    def on_squarifyButton_clicked(change):
        """
        Turn irregular ROIs into squares centered on original ROI centroids.
        This function processes the 'Masks' layer in the napari viewer, replacing irregular ROIs
        with square ROIs of specified size. The squares are centered on the centroids of the 
        original ROIs. It also updates the 'Annotations' layer to match the new square ROIs.
        """
        semiside = squareROISSideWidget.value #side of the square will be this X2 +1

        try:
            mask2 = tb.app.layers['Masks'].data.copy()
            props = measure.regionprops(tb.app.layers['Masks'].data)
            mask2[:] = 0
            for p in props:
                print(p.centroid)
                cx,cy = p.centroid
                cx,cy = int(cx),int(cy)
                mask2[cx-semiside:cx+semiside,cy-semiside:cy+semiside] = p.label

            tb.app.layers['Masks'].data = mask2
        except:
            print('No ROI present, pass')
        
        try:
            annotations2 = tb.app.layers['Annotations'].data.copy()
            annotations = mask2.copy()
            annotations[annotations!=0] = 1
            tb.app.layers['Annotations'].data = annotations
        except:
            print('No Annotations present, pass')
    
    squarifyButton.on_click(on_squarifyButton_clicked)

    def on_saveRois_clicked(change):
        try:
            l = tb.app.layers['Masks']
            l.save(os.path.join(tb.folder,'Masks.tif'))
        except:
            print('No Masks')
        try:
            l = tb.app.layers['Avg']
            l.save(os.path.join(tb.folder,'Avg.tif'))
        except:
            print('No avg image')

        try:
            l = tb.app.layers['Annotations']
            l.save(os.path.join(tb.folder,'Annotations.tif'))
        except:
            print('No annotation image')
    saveROIsbutton.on_click(on_saveRois_clicked)


    def on_loadRois_clicked(change):
        try:
            avgs =  imread(os.path.join(tb.folder,'Avg.tif'))
            try:
                l = tb.app.layers['Avg']
                l.data = avgs
                
            except:
                tb.app.add_image(avgs,name='Avg')
        except:
            pass

        try:
            masks = imread(os.path.join(tb.folder,'Masks.tif'))
            try:
                l = tb.app.layers['Masks']
                l.data = masks
                l.features =  regionprops_table(l.data+1,properties=('area','centroid',   # the +1 is so that it correctly allign in napari
                                                 'orientation',
                                                 'axis_major_length',
                                                 'axis_minor_length'))
            except:
                tb.app.add_labels(masks,name='Masks', opacity = 0.3)
                l = tb.app.layers['Masks']
                l.features =  regionprops_table(l.data+1,properties=('area','centroid',   # the +1 is so that it correctly allign in napari
                                                 'orientation',
                                                 'axis_major_length',
                                                 'axis_minor_length'))
        except:
            pass



        try:
            avgs =  imread(os.path.join(tb.folder,'Annotations.tif'))
            try:
                l = tb.app.layers['Annotations']
                l.data = avgs
                
            except:
                tb.app.add_labels(avgs,name='Annotations', opacity = 1)
        except:
            pass
    loadROIsbutton.on_click(on_loadRois_clicked)


    def on_subtractBackground_clicked(change):
        arr = tb.app.layers['Image'].data[backgroundFrameWidget.value:backgroundFrameWidget.value+5,:,:].mean(0).astype(np.int16)
        data = tb.app.layers['Image'].data - arr
        data[data<0]=0
        data = data.astype(np.uint16)
        tb.app.layers['Image'].data = data
        
    subtractBackgroundButton.on_click(on_subtractBackground_clicked)

    def on_subtract10Background_clicked(change):
        data= tb.app.layers['Image'].data.astype(np.float32) - subtract10FrameWidget.value
        data[data<0] = 0
        tb.app.layers['Image'].data = data.astype(np.uint16)
        
    subtract10BackgroundButton.on_click(on_subtract10Background_clicked)
    
    def bin2d(a,K):
        m_bins = a.shape[0]//K
        n_bins = a.shape[1]//K
        return a.reshape(m_bins, K, n_bins, K).mean(3).mean(1)

    def on_scaleSpace_clicked(changed):
        #tb.app.layers['Image'].data = tb.app.layers['Image'].data[:,::2,::2] # zoom(tb.app.layers['Image'].data, zoom= [1,0.5,0.5] )
        data = tb.app.layers['Image'].data
        data2 = np.zeros((data.shape[0],data.shape[1]//2,data.shape[2]//2))
        for i in range(data.shape[0]):
            data2[i,:,:] = bin2d(data[i,:,:],2)
        tb.app.layers['Image'].data = data2
        tb.width = int(floor(tb.width/2))
        tb.height = int(floor(tb.height/2))

        tb.frameSize = tb.width * tb.height*2
    scaleSpaceButton.on_click(on_scaleSpace_clicked)

    def on_enlarge_labels_clicked(change):
        try:
            data = tb.app.layers['Wave3DRois'].data
            data2=np.zeros((data.shape[0],data.shape[1]*2,data.shape[2]*2),dtype=np.uint16)
            data2[:,::2,::2] = data
            data2[:,1::2,1::2] = data
            data2[:,::2,1::2] = data
            data2[:,1::2,::2] = data
            tb.app.layers['Wave3DRois'].data = data2
        except:
            pass
        
        try:
            data = tb.app.layers['Wave2DRois'].data
            data2=np.zeros((data.shape[0],data.shape[1]*2,data.shape[2]*2),dtype=np.uint16)
            data2[:,::2,::2] = data
            data2[:,1::2,1::2] = data
            data2[:,::2,1::2] = data
            data2[:,1::2,::2] = data
            tb.app.layers['Wave2DRois'].data = data2
        except:
            pass
        
        try:
            sgb = tb.app.layers['BadWaves'].data
            sgb[:,1] = sgb[:,1]*2
            sgb[:,2] = sgb[:,2]*2
            tb.app.layers['BadWaves'].data = sgb
        except:
            pass

        try:
            sgb = tb.app.layers['Points'].data
            sgb[:,1] = sgb[:,1]*2
            sgb[:,2] = sgb[:,2]*2
            tb.app.layers['Points'].data = sgb
        except:
            pass
    enlargeabelsButton.on_click(on_enlarge_labels_clicked)

    def on_scaleTime_clicked(change):
        tb.app.layers['Image'].data = tb.app.layers['Image'].data[::2,::1,::1]  # zoom(tb.app.layers['Image'].data, zoom= [0.5,1,1] )
        tb.nFrames = tb.app.layers['Image'].data.shape[0]
    scaleTimeButton.on_click(on_scaleTime_clicked)
    
    def on_loadhcline_button(change):
        """
        Callback function to load and display a horizontal cell line from a CSV file.

        This function attempts to load horizontal cell line data from a 'hcs.csv' file and display
        it as a shape layer in the viewer. If a layer named 'HCline' already exists, it updates
        the data; otherwise, it creates a new shape layer.

        Parameters
        ----------
        change : object
            Button click event object (not used in function)

        Notes
        -----
        - Expects 'hcs.csv' file to be located one directory up from the current folder
        - CSV data is flipped horizontally before display
        """
        fp = os.path.join(os.path.split(tb.folder)[0],'hcs.csv')
        try:
            hcline = pd.read_csv(fp).values
            try:
                l = tb.app.layers['HCline']
                l.data = hcline[:,::-1]
            except:
                tb.app.add_shapes(hcline[:,::-1],shape_type='path', edge_width=5,name='HCline')
        except:
            print('Can\'t load IHC line')
    loadhclineButton.on_click(on_loadhcline_button)

    def on_savehcline_clicked(change):
        fp = os.path.join(os.path.split(tb.folder)[0],'hcs.csv')
        data = tb.app.layers['HCline'].data[0]
        if data.shape[1]==2:
            df = pd.DataFrame({'X':data[:,1],'Y':data[:,0]})
        elif data.shape[1] == 3:
            df = pd.DataFrame({'X':data[:,2],'Y':data[:,1]})
        df.to_csv(fp,index=False)
    savehclineButton.on_click(on_savehcline_clicked)

    def on_voronoiButton_clicked(change):
        """
        Process and segment calcium waves in image data using Voronoi-Otsu labeling.
        This function performs several key operations:
        1. Chunks the image data to handle memory constraints
        2. Applies Voronoi-Otsu labeling for initial segmentation
        3. Expands and merges labels to refine segmentation
        4. Creates a final labeled image of calcium waves
        5. Generates measurements for each detected wave
        Parameters:
        -----------
        change : ipywidgets.widget.Change
            The change event from the button widget (not used in function)
        Global Dependencies:
        -------------------
        - tb : Object containing application state and image data
        - cle : Object for GPU-accelerated image processing
        - spotSWidget : Widget controlling spot sigma parameter
        - outlineSWidget : Widget controlling outline sigma parameter
        Returns:
        --------
        None
            Results are stored in tb.app.layers['Wave3DRois'] and printed to console
        Notes:
        ------
        - MAXCHUNKSIZE_2 is PC dependent and may need adjustment
        - Warns if too many calcium waves are detected in a chunk
        - Outputs a DataFrame with wave properties: Label, Start, Duration, and Area
        """
        MAXCHUNKSIZE_2 = 786432000  # MAX MEMORY ALLOWED IN MEMORY CARD. WARNING! IT IS PC DEPENDENT. 
        framesXChunk = int(floor(MAXCHUNKSIZE_2/tb.frameSize/4))
        nSteps = int(ceil(tb.nFrames/framesXChunk))
        print('Chunk size: '+ str(framesXChunk) )
        labels = []
        previousLabelMax = 0
        for i in range(nSteps):
            try:
                bb = cle.voronoi_otsu_labeling(tb.app.layers['Image'].data[i*framesXChunk:(i+1)*framesXChunk,:,:], spot_sigma=spotSWidget.value, outline_sigma=outlineSWidget.value)
            except:
                bb = cle.voronoi_otsu_labeling(tb.app.layers['Image'].data[i*framesXChunk:,:,:], spot_sigma=spotSWidget.value, outline_sigma=outlineSWidget.value)
            
            data = cle.pull(bb)
            if data.max()>2000:
                print('Too many ca wave identified between frame '+str(i*framesXChunk)+' and frame ' + str((i+1)*framesXChunk)+'. Try subtracting more background')
                data[:] = 0 # if too many calcium waves identified it is probably a mistake due to the lack of ca waves
                
            
            bb.data.release()
            del bb
            data[data!=0] = data[data!=0] + previousLabelMax
            labels.append(data)

            if data.max()!=0:
                previousLabelMax = data.max()
            
        labs  = np.vstack(labels)

        for i in range(nSteps): # Expand labels
            try:
                labels_gpu = cle.push_zyx(labs[i*framesXChunk:(i+1)*framesXChunk,:,:].astype(np.uint16))
            except:
                labels_gpu = cle.push_zyx(labs[i*framesXChunk:,:,:].astype(np.uint16))
            bb = None
            bb = cle.extend_labels_with_maximum_radius(labels_gpu,bb, 0.5) # expand labels by 0.5 pixel
            bb = cle.merge_touching_labels(bb) # merge touching labels
            data = cle.pull(bb)
            bb.data.release()
            del bb

            try:
                labs[i*framesXChunk:(i+1)*framesXChunk,:,:] = data
            except:
                labs[i*framesXChunk:,:,:] = data
        

        framesXChunk2 = framesXChunk*4
        nSteps2 = int(ceil(tb.nFrames/framesXChunk2))
        for i in range(nSteps2):
            try:
                labs[framesXChunk2*i:framesXChunk2*(i+1),:,:] = cle.merge_touching_labels(labs[framesXChunk2*i:framesXChunk2*(i+1),:,:])
            except:
                labs[framesXChunk2*i:,:,:] = cle.merge_touching_labels(labs[framesXChunk2*i:,:,:])
        

        try:
            tb.app.layers['Wave3DRois'].data = labs
        except:
            tb.app.add_labels(labs, name = 'Wave3DRois')
        

        props = measure.regionprops(labs)
        print('Found '+ str(len(props))+' Ca2+ waves')
        df = pd.DataFrame({
            'Label':[c.label for c in props],
            'Start':[c.bbox[0] for c in props],
            'Duration':[c.bbox[3]-c.bbox[0] for c in props],
            'Area':[c.area for c in props],
            
        })
        print(df.sort_values('Start',axis=0))
    voronoiButton.on_click(on_voronoiButton_clicked)
    
    def on_resetLabels_clicked(change):
        """
        Reset and reorder labels of ROIs in a 3D wave visualization.
        This function processes ROI (Region of Interest) data, reorders labels based on their
        temporal position (start time), and updates the visualization layer with new sequential
        labels. It also prints statistics about detected calcium waves.
        Parameters
        ----------
        change : ipywidgets.widget.Change
            The change event object from the button click (not used in function)
        Notes
        -----
        The function expects:
        - A napari viewer instance (tb.app) with a layer named 'Wave3DRois'
        - The layer data should be a labeled 3D array of ROIs
        The function will:
        1. Reorder ROI labels sequentially based on their starting position
        2. Update the layer with new labels
        3. Print a summary of wave properties including:
           - Label number
           - Start position
           - Duration
           - Area
        Returns
        -------
        None
            Updates the napari viewer layer in-place and prints wave statistics
        """
        data = tb.app.layers['Wave3DRois'].data
        #data = measure.label(data)
        data2 = data.copy()
        props = measure.regionprops(data)
        orderedIndex= list([np.argsort([c.bbox[0] for c in props])][0])
        unorderedLabels = [c.label for c in props]
        orderedLabels =[unorderedLabels[i] for i in orderedIndex]
        for i,el in enumerate(orderedLabels):
            #print(i)
            data2[data==el] = i+1
        tb.app.layers['Wave3DRois'].data = data2
        
        
        props = measure.regionprops(data2)
        print('Found '+ str(len(props))+' Ca2+ waves')
        print(pd.DataFrame({
            'Label':[c.label for c in props],
            'Start':[c.bbox[0] for c in props],
            'Duration':[c.bbox[3]-c.bbox[0] for c in props],
            'Area':[c.area for c in props],
            
        }))

        del data
        del data2
    resetLabelsButton.on_click(on_resetLabels_clicked)

    def on_saveWaves_clicked(change):
        try:
            l = tb.app.layers['Wave3DRois']
            wd = l.data
            #check if the labels are ok first
            props = measure.regionprops(wd)
            orderedIndex= list([np.argsort([c.bbox[0] for c in props])][0])
            unorderedLabels = [c.label for c in props]
            #if labels have missing numbers or they are not in a sequence, reorder them
            if (len(unorderedLabels) != max(unorderedLabels)) or (np.diff(unorderedLabels)<0).any():
                print('Labels not in order rearranging first')
                on_resetLabels_clicked(None)
                l = tb.app.layers['Wave3DRois']
                wd = l.data

            imsave(os.path.join(tb.folder,'Wave3DRois.tif'), wd.astype(np.uint16))
            print('Waves saved')
            del wd
        except KeyError:
            pass
        try:
            l = tb.app.layers['Wave2DRois']
            wd = l.data
            #check if the labels are ok first
            props = measure.regionprops(wd)
            orderedIndex= list([np.argsort([c.bbox[0] for c in props])][0])
            unorderedLabels = [c.label for c in props]
            #if labels have missing numbers or they are not in a sequence, reorder them
            if (len(unorderedLabels) != max(unorderedLabels)) or (np.diff(unorderedLabels)<0).any():
                print('Labels not in order rearranging first')
                on_resetLabels_clicked(None)
                l = tb.app.layers['Wave2DRois']
                wd = l.data

            imsave(os.path.join(tb.folder,'Wave2DRois.tif'), wd.astype(np.uint16))            
            del wd
        except KeyError:
            pass


        try:
            l=tb.app.layers['BadWaves']
            l.save(os.path.join(tb.folder,'BadWaves.csv'))
        except KeyError:
            pass

        try:
            l=tb.app.layers['Points']
            l.save(os.path.join(tb.folder,'Points.csv'))
        except KeyError:
            pass

        #l.save(os.path.join(tb.folder,'Wave3DRois.tif'))
    saveWavesButton.on_click(on_saveWaves_clicked)

    globalprops = []
    def on_loadWaves_clicked(change):
        """
        Handle the event when 'Load Waves' button is clicked.
        This function attempts to load and display various wave-related data files:
        - 'Wave3DRois.tif': 3D wave regions of interest
        - 'Wave2DRois.tif': 2D wave regions of interest 
        - 'Points.csv': Point coordinates
        - 'BadWaves.csv': Additional point coordinates
        For wave ROIs (both 2D and 3D), it:
        1. Loads the TIFF file
        2. Prints the number of detected Ca2+ waves
        3. Displays properties table with Label, Start time, Duration and Area
        4. Adds or updates the napari layer with the wave data
        For point data:
        - Loads coordinates from CSV files
        - Adds points to the napari viewer
        Parameters
        ----------
        change : ipywidgets.widgets.widget_core.CallbackDispatcher
            The change event object (not used in function)
        Global Variables
        --------------
        globalprops : RegionProps
            Stores the region properties of 3D waves for later use
        Notes
        -----
        All file loading operations are wrapped in try-except blocks to handle missing files gracefully.
        Files are expected to be in the directory specified by tb.folder.
        """
        global globalprops
        try:
            avgs =  imread(os.path.join(tb.folder,'Wave3DRois.tif'))

            print('Found '+ str(avgs.max())+' Ca2+ waves')
            props = measure.regionprops(avgs)
            print(pd.DataFrame({
                'Label':[c.label for c in props],
                'Start':[c.bbox[0] for c in props],
                'Duration':[c.bbox[3]-c.bbox[0] for c in props],
                'Area':[c.area for c in props],
                
            }))
            globalprops = props
            try:
                l = tb.app.layers['Wave3DRois']
                l.data = avgs
                
            except:
                tb.app.add_labels(avgs,name='Wave3DRois')
        except:
            pass

        try:
            avgs =  imread(os.path.join(tb.folder,'Wave2DRois.tif'))

            print('Found '+ str(avgs.max())+' Ca2+ waves')
            props = measure.regionprops(avgs)
            print(pd.DataFrame({
                'Label':[c.label for c in props],
                'Start':[c.bbox[0] for c in props],
                'Duration':[c.bbox[3]-c.bbox[0] for c in props],
                'Area':[c.area for c in props],
                
            }))

            try:
                l = tb.app.layers['Wave2DRois']
                l.data = avgs
                
            except:
                tb.app.add_labels(avgs,name='Wave2DRois')
        except:
            pass

        try:
            points = pd.read_csv(os.path.join(tb.folder,'Points.csv'),usecols = [1,2,3])
            tb.app.add_points(points)
        except:
            pass

        try:
            points = pd.read_csv(os.path.join(tb.folder,'BadWaves.csv'),usecols = [1,2,3])
            tb.app.add_points(points,name='BadWaves')
        except:
            pass


    loadWavesButton.on_click(on_loadWaves_clicked)

    def on_next_wave_clicked(c):
        global globalprops
        currentWave = currentWaveWidget.value+1
        #props = measure.regionprops(tb.app.layers['Wave3DRois'].data)
        p = globalprops[currentWave-1]
        frame = int((p.bbox[3] + p.bbox[0])/2)
        tb.app.dims.set_point(axis=0,value=frame)
        currentWaveWidget.value = currentWave
    nextWaveButton.on_click(on_next_wave_clicked)

    def on_prev_wave_clicked(c):
        global globalprops
        currentWave = currentWaveWidget.value-1
       # props = measure.regionprops(tb.app.layers['Wave3DRois'].data)
        p = globalprops[currentWave-1]
        frame = int((p.bbox[3] + p.bbox[0])/2)
        tb.app.dims.set_point(axis=0,value=frame)
        currentWaveWidget.value = currentWave
    prevWaveButton.on_click(on_prev_wave_clicked)

    def on_next_point_clicked(c):
        try:
            currentPoint = currentPointWidget.value + 1
            points = tb.app.layers['Points'].data
            
            tb.app.dims.set_point(axis=0,value=int(points[currentPoint-1,0]))
            currentPointWidget.value = currentPoint
        except:
            pass
    nextPointButton.on_click(on_next_point_clicked)

    def on_prev_point_clicked(c):
        if currentPointWidget.value >1:
            currentPoint = currentPointWidget.value - 1
            points = tb.app.layers['Points'].data
            
            tb.app.dims.set_point(axis=0,value=int(points[currentPoint-1,0]))
            currentPointWidget.value = currentPoint
    prevPointButton.on_click(on_prev_point_clicked)


    def on_loadKymo_clicked(c):
        """
        Load and process a kymograph image with green and red channels.
        This function loads a kymograph TIFF file showing activity, processes it by:
        1. Removing the blue channel
        2. Applying Gaussian blur
        3. Subtracting background using 5th percentile
        4. Adding processed image to viewer with shapes layer
        The kymograph contains:
        - Green channel: line drawn on bulk of GER
        - Red channel: line drawn across hair cells
        Args:
            c: Click event parameter (unused)
        Returns:
            None: Results are added directly to the viewer
        Dependencies:
            - tifffile: for image reading
            - numpy: for array operations
            - cle: for GPU-accelerated image processing
        """

        kymo =  tifffile.imread(os.path.join(tb.folder,'kymoHCS.tif'))
        kymo = kymo[:2,:,:] # remove blue channel
        result_image = None
        test_image_gpu = cle.push(kymo)
        result_image = cle.gaussian_blur(test_image_gpu,sigma_z = 0,sigma_y = 5,sigma_x = 5)
        #result_image = cle.top_hat_box(result_image,result_image,radius_y=5,radius_x=5)
        result_image = result_image - np.expand_dims(np.percentile(result_image,5,axis=1),1)
        
        tb.app.add_image(result_image,channel_axis = 0)
        tb.app.add_shapes(None,name='Kymo shapes',face_color = [0,0,0,0])
        #tb.app.add_image(result_image,channel_axis = 0)

    loadKymoButton.on_click(on_loadKymo_clicked)
    
    def on_saveKymo_clicked(c):
        """
        Event handler for saving kymograph shapes to a CSV file.

        This function saves the geometric shapes drawn around kymographs in two formats:
        - Rectangles: Delineate the hair cell region
        - Ellipses: Mark the bulk of the Greater Epithelial Ridge (GER)

        The shapes are saved from the 'Kymo shapes' layer to a CSV file named 'kymoShapes.csv'
        in the specified folder location.

        Parameters
        ----------
        c : event
            Click event object containing event data

        Returns
        -------
        None
        """

        data = tb.app.layers['Kymo shapes']
        data.save(os.path.join(tb.folder,'kymoShapes.csv'))
    saveKymoShapesButton.on_click(on_saveKymo_clicked)

    def on_loadKymoShapesButton_clicked(c):
        tb.app.open(os.path.join(tb.folder,'kymoShapes.csv'),layer_type='shapes',face_color = [0,0,0,0],name = 'Kymo shapes')
        
    loadKymoShapesButton.on_click(on_loadKymoShapesButton_clicked)


     # FIBRES CALLBACKS
    from skimage import morphology
    
    def on_tophat_clicked(click):
        img = tb.app.layers['Avg'].data
        blobs = morphology.white_tophat(img,morphology.disk(topHatRadius.value))
        try:
            l=tb.app.layers['TophatFilter']
            l.data = blobs
        except: 
            tb.app.add_image(blobs,name='TophatFilter')
    topHatButton.on_click(on_tophat_clicked)

    def on_voronoiFibres_clicked(click):
        """
        Processes image data to detect and label fibres using Voronoi-Otsu labeling.
        This function applies several image processing steps:
        1. Executes average and tophat filtering pre-processing
        2. Performs Voronoi-Otsu labeling on the filtered image
        3. Removes small regions based on area threshold
        4. Reorders labels from left to right
        5. Updates or creates a new layer with the processed labels
        Parameters
        ----------
        click : event
            Mouse click event (not used in function)
        Global Dependencies
        -----------------
        - Requires initialized tb.app with 'TophatFilter' layer
        - Uses spotSFibresWidget.value for sigma values
        - Uses areaLimitFibresWidget.value for area threshold
        Returns
        -------
        None
            Updates or creates 'SGN ROIs' layer in tb.app
        """
        on_justAvgButton_clicked(None)
        on_tophat_clicked(None)

        bb = cle.voronoi_otsu_labeling(tb.app.layers['TophatFilter'].data, spot_sigma=spotSFibresWidget.value, outline_sigma=spotSFibresWidget.value)
 
        
        # reset label number
        mask = measure.label(bb)

        #sort masks from left to right
        props = measure.regionprops(mask)
        
        masks2 = mask.copy()
        #remove small rois
        for c in props:
            if c.area<areaLimitFibresWidget.value:
                masks2[mask==c.label] = 0

        # reset label number
        masks2 = measure.label(masks2)
        masks3 = masks2.copy()

        props = measure.regionprops(masks2)
        orderedLabels = np.argsort([c.centroid[1] for c in props])+1
        
        for i,el in enumerate(orderedLabels):

            masks3[masks2==el] = i+1

        masks2 = masks3


        #Erode labels
        #masks2 = pyp.pull(pyp.erode_labels(masks2))

        try:
            l=tb.app.layers['SGN ROIs']
            l.data = masks2
        except: 
            tb.app.add_labels(masks2,name='SGN ROIs')
                
    voronoiFibresButton.on_click(on_voronoiFibres_clicked)

    def on_segmentHCFibresButton_clicked(click):
        """
        Segments inner hair cells in an image using a pre-trained Cellpose model.
        This function processes the 'Avg' layer image data through a custom Cellpose model
        trained specifically for hair cells in images with GCaMP-labelled fibres (i.e., it labels the hole between fibres). It performs segmentation, filters out
        small ROIs, and reorders the masks from left to right.
        Parameters:
            click : event
                Button click event (unused in function)
        Returns:
            None
                Modifies or creates a 'Masks' layer in the napari viewer with the segmented data
        Dependencies:
            - requires a pre-trained Cellpose model at './cellposemodels/hcFibremodel'
            - needs an 'Avg' layer in the napari viewer
            - uses radiusFbiresWidget.value for diameter parameter
        Notes:
            - Filters out ROIs with area < 750 pixels
            - Reorders masks from left to right based on centroid position
            - If 'Masks' layer exists, updates it; if not, creates new layer
        """
        arr = tb.app.layers['Avg'].data
        #model = models.Cellpose(gpu=False, model_type='cyto2')
        model = models.CellposeModel(pretrained_model='./cellposemodels/hcFibremodel')
        masks, flows, styles = model.eval(arr, diameter=radiusFbiresWidget.value, channels=[0,0], net_avg=True,cellprob_threshold = 0.0,
                                                 flow_threshold=27.0,resample=False)  
        
        #sort masks from left to right
        props = measure.regionprops(masks)
        
        masks2 = masks.copy()
        #remove small rois
        for c in props:
            if c.area<750:
                masks2[masks==c.label] = 0

        props = measure.regionprops(masks2)
        orderedLabels = np.argsort([c.centroid[1] for c in props])+1
        masks3 = masks2.copy()
        for i,el in enumerate(orderedLabels):

           masks3[masks2==el] = i+1

        masks = masks3

        try:
            l=tb.app.layers['Masks']
            l.data = masks
        except: 
            tb.app.add_labels(masks,name='Masks')
    segmentHCFibresButton.on_click(on_segmentHCFibresButton_clicked)

    def on_plotFibres_clicked(click):
        """
        Reorder an plot SGN ROIs traces
        """

        if 'SGN ROIs' in [layer.name for layer in tb.app.layers]:
            mask = tb.app.layers['SGN ROIs'].data
            l = tb.app.layers['SGN ROIs']
            
            # reset label number
            mask = measure.label(mask)

            #sort masks from left to right
            props = measure.regionprops(mask)
            
            masks2 = mask.copy()
            #remove small rois
            for c in props:
                if c.area<areaLimitFibresWidget.value:
                    masks2[mask==c.label] = 0




            # reset label number
            masks2 = measure.label(masks2)
            masks3 = masks2.copy()

            props = measure.regionprops(masks2)
            orderedLabels = np.argsort([c.centroid[1] for c in props])+1
            
            for i,el in enumerate(orderedLabels):

                masks3[masks2==el] = i+1

            masks2 = masks3
            l.data = masks2
            mask = l.data
            l.features =  regionprops_table(l.data+1,properties=('area','centroid',   # the +1 is so that it correctly allign in napari
                                        'orientation',
                                        'axis_major_length',
                                        'axis_minor_length'))
            fig.data = []

            for i in range(1,mask.max()+1):
                if np.size(np.argwhere(mask==i))>0:
                    z = tb.array[:,np.argwhere(mask==i)[:,0],np.argwhere(mask==i)[:,1]].mean(1)
                    #find removed frames
                    dz = np.diff(z)
                    keep = np.argwhere(dz!=0)
                    #print(keep.shape)
                    color = l.get_color(i)*255
                    color = "rgb({} , {} ,{}, {})".format( *color)
                    fig.add_scatter(y=z[keep[:,0]],x = np.arange(z.size)[keep[:,0]],line=go.scatter.Line(color=color),name='Roi '+ str(i))
    plotFibresButton.on_click(on_plotFibres_clicked)

    def on_annotateFibres_clicked(click):
        """
        Generate initial annotation of nerve fibres and boutons in an image based on their spatial relationships.
        This annotation can be manually adjusted by the user
        This function processes SGN (Spiral Ganglion Neuron) ROIs and mask data to classify
        neural structures into different categories based on their position relative to a reference line
        and distance from other structures.
        Categories:
        1: Modiolar boutons
        2: Pillar boutons 
        3: Modiolar fibres
        4: Pillar fibres
        5: Undetermined boutons (when too close to reference line)
        Parameters
        ----------
        click : Event
            Click event that triggers the function (not used in function body)
        Returns
        -------
        None
            Updates or creates an 'Annotations' layer in the napari viewer
        Notes
        -----
        Requires following layers in the napari viewer:
        - 'SGN ROIs': Label image containing SGN regions of interest
        - 'Masks': Label image containing mask data
        The classification uses a cutoff distance of 75 pixels and a 10 pixel threshold
        for determining if a structure is too close to the reference line.
        """
        sgnMasks = tb.app.layers['SGN ROIs'].data
        propsSGN = measure.regionprops(sgnMasks)

        annotations = sgnMasks.copy()
        cutoff = 75


        masks = tb.app.layers['Masks'].data

        # reset label number
        masks2 = measure.label(masks)
        masks3 = masks2.copy()

        props = measure.regionprops(masks2)
        orderedLabels = np.argsort([c.centroid[1] for c in props])+1

        for i,el in enumerate(orderedLabels):

            masks3[masks2==el] = i+1


        tb.app.layers['Masks'].data = masks3
        masks = tb.app.layers['Masks'].data
        props = measure.regionprops(masks)
        line = shapely.LineString(np.array((props[0].centroid,props[-1].centroid)))

        '''
        1: modiolar boutons
        2: pillar boutons
        3: modiolar fibres
        4: pillar fibres
        5: undetermined boutons
        '''
        for p in propsSGN:
            
            hcdistances = []
            for p2 in props:
                
                d = shapely.Point(p.centroid).distance(shapely.Point(p2.centroid))
                hcdistances.append(d)
            
            mindist = min(hcdistances)
            point = shapely.Point(p.centroid)
            
            #distanceFromLine = line.distance(point)
            sgnMasks2 = sgnMasks.copy()
            sgnMasks2[sgnMasks2!=p.label] = 0
            perimeter = measure.find_contours(sgnMasks2)[0]
            boutonShape = shapely.Polygon(perimeter)
            distanceFromLine = line.distance(boutonShape)

            if mindist<cutoff:
                if distanceFromLine<10:#If the shape is too close to the line, don't assign to modiolar or pillar
                    annotations[annotations==p.label] = 5
                else:
                    if isLeft(line,point):
                        annotations[annotations==p.label] = 1
                    else:
                        annotations[annotations==p.label] = 2
            else:
                
                if isLeft(line,point):
                    annotations[annotations==p.label] = 3
                else:
                    annotations[annotations==p.label] = 4
        
        try:
            l=tb.app.layers['Annotations']
            l.data = annotations
        except: 
            tb.app.add_labels(annotations,name='Annotations')
    annotateFibresButton.on_click(on_annotateFibres_clicked)

    def on_exportFibreTraces_clicked(click):
        mask = tb.app.layers['SGN ROIs'].data
        zs = []
        df = pd.DataFrame()
        for i in range(1,mask.max()+1):
            if np.size(np.argwhere(mask==i))>0:
                z = tb.array[:,np.argwhere(mask==i)[:,0],np.argwhere(mask==i)[:,1]].mean(1)
                #find removed frames
                dz = np.diff(z)
                keep = np.argwhere(dz!=0)

                xs = np.arange(z.size)
                df['ROI_'+str(i)] = z

        df ['Frame'] = xs
        df.to_csv(os.path.join(tb.folder,'traces.csv'))
    exportROIsFibresButton.on_click(on_exportFibreTraces_clicked)
    
    def on_exportFibreAnnotations_clicked(click):
        try:
            l = tb.app.layers['Masks']
            l.save(os.path.join(tb.folder,'Masks.tif'))
        except:
            print('No Masks')
        try:
            l = tb.app.layers['Avg']
            l.save(os.path.join(tb.folder,'Avg.tif'))
        except:
            print('No avg image')

        try:
            l = tb.app.layers['Annotations']
            l.save(os.path.join(tb.folder,'Annotations.tif'))
        except:
            print('No annotation image')

        try:
            l = tb.app.layers['SGN ROIs']
            l.save(os.path.join(tb.folder,'SGN ROIs.tif'))
        except:
            print('No SGN ROIs image')

        try:
            l = tb.app.layers['SGN-HC mask']
            l.save(os.path.join(tb.folder,'SGN-HC mask.tif'))
        except:
            print('No SGN-HC mask image')

    exportAnnotationsFibresButton.on_click(on_exportFibreAnnotations_clicked)
    
    def on_loadAnnotationsButton_clicked(click):
        on_loadRois_clicked(None)
        try:
            avgs =  imread(os.path.join(tb.folder,'SGN ROIs.tif'))
            try:
                l = tb.app.layers['SGN ROIs']
                l.data = avgs
                
            except:
                tb.app.add_labels(avgs,name='SGN ROIs')
        except:
            pass

        try:
            avgs =  imread(os.path.join(tb.folder,'SGN-HC mask.tif'))
            try:
                l = tb.app.layers['SGN-HC mask']
                l.data = avgs
                
            except:
                tb.app.add_labels(avgs,name='SGN-HC mask')
        except:
            pass

    loadAnnotationsButton.on_click(on_loadAnnotationsButton_clicked)
    
    def on_assignFibreButton_clicked(click):
        """
        Initial assignment of neural fibers (boutons) to hair cells based on spatial relationships in microscopy images.
        This assignment can be manually changed by the user, and it is further refined programmatically in the following analysis
        for undertermined fibres (based on activity).
        This function analyzes the spatial relationship between neural fibers and hair cells by:
        1. Checking for direct overlap/intersection between boutons and hair cells
        2. If no direct overlap, checking proximity within a cutoff distance
        3. Marking unassigned boutons with special labels
        Parameters
        ----------
        click : Event
            Button click event (unused in function)
        Returns
        -------
        None
            Creates or updates a 'SGN-HC mask' layer in the napari viewer
        Notes
        -----
        Requires the following napari layers to exist:
        - 'Annotations': Label image containing bouton annotations
        - 'Masks': Label image containing hair cell masks
        - 'SGN ROIs': Label image containing segmented neural fibers
        The function creates a new label image where:
        - Each bouton pixel is labeled with its associated hair cell ID
        - Boutons with no hair cell association are labeled as 666
        """
        #load the masks
        annotations = tb.app.layers['Annotations'].data
        masks = tb.app.layers['Masks'].data
        sgnrois = tb.app.layers['SGN ROIs'].data
        #measure the region properties
        annotprops = measure.regionprops(annotations)
        sgnprops = measure.regionprops(sgnrois) 
        hcprops = measure.regionprops(masks)


        sgnhcmasks = np.zeros(sgnrois.shape,dtype = np.uint16)
        #Assign bouton based on superposition with hcs
        for p in sgnprops:
            sgnrois2 = sgnrois.copy()
            sgnrois2[sgnrois!=p.label] = 0
            perimeter = measure.find_contours(sgnrois2)[0]
            boutonShape = shapely.Polygon(perimeter)
            superposition = 0
            for m in hcprops:
                masks2 = masks.copy()
                masks2[masks!=m.label] = 0
                hcperimeter = measure.find_contours(masks2)[0]
                hcShape = shapely.Polygon(hcperimeter)
                
                #Assign a bouton to the hc it has the most superposition with
                if hcShape.intersects(boutonShape):
                    if hcShape.intersection(boutonShape).area>superposition:
                        superposition = hcShape.intersection(boutonShape).area
                        sgnhcmasks[sgnrois==p.label] = m.label

            
            #if it doesn't intersect still assign to a cell if it is closer than x pixel
            if superposition ==0:
                cutoff = 3 #pixels
                for m in hcprops:
                    masks2 = masks.copy()
                    masks2[masks!=m.label] = 0
                    hcperimeter = measure.find_contours(masks2)[0]
                    hcShape = shapely.Polygon(hcperimeter)
                    if hcShape.distance(boutonShape)<cutoff:
                        sgnhcmasks[sgnrois==p.label] = m.label
      
        #For every bouton that doesn't touch an hc, set it as undetermined (label =999).
        for s in sgnprops:
            boutontype = np.median(annotations[sgnrois==s.label])
            
            if (boutontype==1) or (boutontype==2):
                assignedHC =  np.median(sgnhcmasks[sgnrois==s.label])
                if assignedHC == 0:
                    sgnhcmasks[sgnrois==s.label] = 666
            elif boutontype==5:
                sgnhcmasks[sgnrois==s.label] = 666
        
        try:
            l=tb.app.layers['SGN-HC mask']
            l.data = sgnhcmasks
        except: 
            tb.app.add_labels(sgnhcmasks,name='SGN-HC mask')
        
    assignFibresButton.on_click(on_assignFibreButton_clicked)
    
    display(ui)
    return fig

def determineCellTypes(masks,annotations):
    """
    Compare ROI image with annotations to determine cell types for each region of interest.

    Parameters
    ----------
    masks : ndarray
        Binary image where each ROI is labeled with a unique integer.
    annotations : ndarray
        Image containing cell type annotations where:
        1 = IHC (Inner Hair Cells)
        2 = OHC (Outer Hair Cells)
        3 = SCs (Supporting Cells)

    Returns
    -------
    pandas.Series
        Series where index is 'ROI_<label>' and values are the cell types (1, 2, or 3).
        NaN values indicate ROIs with no corresponding annotations.

    Notes
    -----
    Cell type for each ROI is determined by taking the median value of all annotated
    pixels within that ROI's area. ROIs with no annotated pixels are assigned NaN.
    """
    regions = measure.regionprops(masks)
    cellTypes = pd.Series(dtype=float)
    for r in regions:
        annotations2 = annotations.copy()
        annotations2[masks!=r.label]=0
        if annotations2[annotations2!=0].size!=0:
            cellType = np.median(annotations2[annotations2!=0])#.mean()
            cellTypes['ROI_'+str(r.label)] = cellType
        else:
            cellTypes['ROI_'+str(r.label)] = np.nan
        #if cellType%1!=0:
         #   print(annotations2[annotations2!=0].mean())
    return cellTypes

def determineCentroids(masks):
    '''
    Return image centroids
        '''
    regions = measure.regionprops(masks)
    centroids = pd.Series(dtype=float)
    for r in regions:
        centroids['ROI_'+str(r.label)] = r.centroid
        #centroids.append(r.centroid)
    return centroids

def extractImagesMaskMatching(folder, onlyIHCs = True):
    """
    Extracts and processes image masks from a specified folder, optionally filtering for Inner Hair Cells (IHCs).
    This function loads mask files and their corresponding annotations, processes them to identify and
    label cell types, and returns both the average image and the processed masks. If matching masks
    already exist, it loads them directly instead of processing.
    Parameters
    ----------
    folder : str
        Path to the root folder containing the 'processedMovies' subdirectory
    onlyIHCs : bool, optional
        If True, only keeps Inner Hair Cells in the mask (default is True)
    Returns
    -------
    tuple
        A tuple containing:
        - avg : ndarray
            The average image loaded from 'Avg.tif'
        - masks : ndarray
            The processed masks, either loaded from 'MatchingMasks.tif' or newly processed
            from 'Masks.tif' and 'Annotations.tif'
    Notes
    -----
    The function requires the following files in the 'processedMovies' subdirectory:
    - 'Masks.tif'
    - 'MatchingMasks.tif' (optional)
    - 'Annotations.tif' (if MatchingMasks.tif is not found)
    - 'Avg.tif'
    If 'MatchingMasks.tif' is not found, the function processes the masks by:
    1. Determining cell types from masks and annotations
    2. Filtering for IHCs if onlyIHCs is True
    3. Reordering labels based on vertical position (centroid y-coordinate)
    """
    filename = os.path.join(folder,'processedMovies','Masks.tif')
    filename2 =  os.path.join(folder,'processedMovies','MatchingMasks.tif')
    filename3 =  os.path.join(folder,'processedMovies','Avg.tif')
    try:
        masks = tifffile.imread(filename2)
    except FileNotFoundError:
        filename4 =  os.path.join(folder,'processedMovies','Annotations.tif')
        print('No matching masks file found, loading masks')
        masks = tifffile.imread(filename)
        annotations = tifffile.imread(filename4)

        
        cellTypes = determineCellTypes(masks,annotations)
        
        regions = measure.regionprops(masks)
        if onlyIHCs:
            for r in regions:
                if cellTypes['ROI_'+str(r.label)] != 1:
                    masks[masks==r.label] = 0

        masks2 = masks.copy()
        props = measure.regionprops(masks2)
        orderedLabels = np.argsort([c.centroid[1] for c in props])+1


        # reset label number
        masks2 = measure.label(masks2)
        masks3 = masks2.copy()
        props = measure.regionprops(masks2)
        orderedLabels = np.argsort([c.centroid[1] for c in props])+1

        
        for i,el in enumerate(orderedLabels):
            masks3[masks2==el] = i+1
        masks = masks3
         
    avg = tifffile.imread(filename3)

    return (avg,masks)

def renderAnnotationsMaskMatching(tb,avg,masks):
    try:
        l = tb.app.layers['Avg']
        l.data = avg
    except:
        tb.app.add_image(avg,name='Avg',visible=True)

    try:
        l = tb.app.layers['MatchingMasks']
        l.data = masks
    except:
        tb.app.add_labels(masks,name='MatchingMasks',visible=True,opacity=0.3)

def maskMatching(master,onlyIHCs = True):
    """
    Match ROIs (Regions of Interest) from different recordings of the same area using an interactive interface.
    This function creates a graphical user interface with widgets that can be used in a jupyter notebook
    to help match and align ROIs across multiple recordings.
    It allows for manual adjustment of ROI positions and ordering, as well as saving the matched masks.
    Parameters
    ----------
    master : pandas.DataFrame
        DataFrame containing information about different recordings. Must include columns:
        - 'Independent recordings number': identifier for each recording session
        - 'Folder': path to the recording folder
        - 'Pixel height': height of each recording in pixels
    onlyIHCs : bool, optional
        If True, only Inner Hair Cells are considered. Defaults to True.
    Returns
    -------
    None
        Displays an interactive widget interface with:
        - Recording number slider
        - Navigation buttons (Previous/Next)
        - Save button for storing matched masks
        - Order ROIs button for left-to-right arrangement
        - Shift sliders for adjusting ROI positions
    Notes
    -----
    The interface includes:
    - Up to 7 shift sliders for fine-tuning ROI positions
    - Option to automatically order ROIs from left to right
    - Capability to save matched masks to individual recording folders
    - Live preview of mask matching results
    The matching masks are saved as 'MatchingMasks.tif' in each recording's 'processedMovies' folder.
    """

    identifiers = master['Independent recordings number'].unique()
    xw = widgets.IntSlider(min=1,max=np.size(identifiers),step=1,value=0,continuous_update=False,description='Recording #')
    prevButton = widgets.Button(description = 'Previous')
    prevButton.style.button_color = 'pink' 
    nextButton = widgets.Button(description = 'Next')
    nextButton.style.button_color = 'pink' 
    orderButton = widgets.Button(description = 'Order ROIs l-r')
    orderButton.style.button_color = 'blue' 

    selectDropDown = widgets.Dropdown(options=[0], value=0, description='Select recording:', disabled=False,) 
    xshift1 = widgets.FloatSlider(min=-5,max=5,step=1,value=0,continuous_update=False,description='Shift 1')
    xshift2 = widgets.FloatSlider(min=-5,max=5,step=1,value=0,continuous_update=False,description='Shift 2')
    xshift3 = widgets.FloatSlider(min=-5,max=5,step=1,value=0,continuous_update=False,description='Shift 3')
    xshift4 = widgets.FloatSlider(min=-5,max=5,step=1,value=0,continuous_update=False,description='Shift 4')
    xshift5 = widgets.FloatSlider(min=-5,max=5,step=1,value=0,continuous_update=False,description='Shift 5')
    xshift6 = widgets.FloatSlider(min=-5,max=5,step=1,value=0,continuous_update=False,description='Shift 6')
    xshift7 = widgets.FloatSlider(min=-5,max=5,step=1,value=0,continuous_update=False,description='Shift 7')
    xshift = [xshift1,xshift2,xshift3,xshift4,xshift5,xshift6,xshift7]



    saveButton = widgets.Button(description = 'Save')
    saveButton.style.button_color = '#A4EA30' 


    
    vbox = widgets.VBox(xshift)
    hbox = widgets.HBox((prevButton,nextButton,saveButton,orderButton, vbox))

    output = widgets.Output()
    ui = widgets.VBox([xw,hbox, output])

    tb = thorlabsFile()   

    def on_next_clicked(click):
        if xw.value< xw.max:
            xw.value = xw.value+1
    nextButton.on_click(on_next_clicked)

    
    def on_prev_clicked(click):
        if xw.value> xw.min:
            xw.value = xw.value - 1
    prevButton.on_click(on_prev_clicked)
    
    def on_save_clicked(click):
        imgs = tb.app.layers['MatchingMasks'].data
        
        
        el = master[master['Independent recordings number']==identifiers[xw.value-1]]
        nImages = el.shape[0]

        #singleHeight = int(img.shape[0]/nImages)
        #singleHeight = int(el.iloc[0]['Pixel height'])
        #count = 0
        cumHeight = 0
        for j,row in el.iterrows():
            singleHeight = int(row['Pixel height'])
            #img = imgs[count*singleHeight:(count+1)*singleHeight, :]
            img = imgs[cumHeight:cumHeight+singleHeight, :]
            tifffile.imwrite(os.path.join(row['Folder'],'processedMovies','MatchingMasks.tif'),img)
            #count = count + 1
            cumHeight = cumHeight + singleHeight
    saveButton.on_click(on_save_clicked)
    
    def on_order_clicked(click):
        '''
        Note that this is an unprecise method based on the average centroid of each roi. Double check the result
        '''

        combinedRois = tb.app.layers['MatchingMasks'].data
        uniqueRois = np.array(list(set(combinedRois.ravel()))) # create a list of all the unique rois
        props = measure.regionprops(combinedRois) #get the properties

        orderedLabels = np.argsort([c.centroid[1] for c in props])+1 # sort the position of the rois 
        orderedUniqueRois = uniqueRois[orderedLabels] # sort the rois numbers from left to right

        combinedRois2 = combinedRois.copy()

        for i, el in enumerate(orderedUniqueRois):
            combinedRois2[combinedRois==el] = i+1

        tb.app.layers['MatchingMasks'].data = combinedRois2
    orderButton.on_click(on_order_clicked)


    def f(x,shift1,shift2,shift3,shift4,shift5,shift6,shift7):
        el = master[master['Independent recordings number']==identifiers[x-1]]
        print(el.iloc[0]['Folder'])
        avgs = []
        masks = []  
        for j,row in el.iterrows():
            avg,mask = extractImagesMaskMatching(row['Folder'],onlyIHCs=onlyIHCs)
            avgs.append(avg)
            masks.append(mask)

        for i in range(7):
            try:
                mmax = masks[i].max()+1
                masks2 = masks[i].copy()
                for j in range(1,mmax):
                    if j + xshift[i].value>0:
                        masks2[masks[i]==j] = j + xshift[i].value
                    else:
                        masks2[masks[i]==j] = mmax + j + xshift[i].value - 1
                masks2[masks2<0] = 0
                masks[i] = masks2
            except IndexError:
                break
        img = np.vstack(avgs)
        img2 = np.vstack(masks)
        renderAnnotationsMaskMatching(tb,img,img2)
        
    out = widgets.interactive_output(f, {'x': xw,'shift1':xshift1,'shift2':xshift2,'shift3':xshift3,'shift4':xshift4,'shift5':xshift5,'shift6':xshift6,'shift7':xshift7})
    
    display(ui,out)

